# Research System Design

## Overview

The research system provides structured, project-specific knowledge management for Claude Code agents. Research is stored in a predictable location that new agents can discover without conversation context.

## Folder Structure

```
{project_root}/.claude/research/
├── README.md                    # Index and overview of all research
├── entries/
│   ├── RES-20260202-001.md     # Individual research entries
│   ├── RES-20260202-002.md
│   └── ...
├── kits/
│   ├── auth-strategy-kit.md     # Compiled knowledge kits
│   ├── api-design-kit.md
│   └── ...
└── .metadata.json               # Machine-readable index
```

## Design Principles

1. **Project-Specific**: Research belongs to the project context, not global
2. **Predictable Discovery**: New agents find research by reading directory structure
3. **Minimal Context Bloat**: Research subagent handles heavy lifting; calling agents get summaries
4. **Temporal Awareness**: Track freshness, flag staleness
5. **Traceability**: Link research → decisions → code
6. **No Overcomplications**: Simple file-based system, no external dependencies

## File Formats

### README.md (Research Index)

Human-readable index at `{project}/.claude/research/README.md`:

```markdown
# Research Index

**Project:** {project_name}
**Created:** {date}
**Last Updated:** {date}
**Total Entries:** {count}
**Active Kits:** {count}

## Recent Research

| ID | Date | Topic | Status | Kit |
|----|------|-------|--------|-----|
| RES-20260202-002 | 2026-02-02 | GraphQL multi-tenant patterns | fresh | api-design-kit |
| RES-20260128-001 | 2026-01-28 | REST vs GraphQL comparison | aging | api-design-kit |

## Knowledge Kits

- **[auth-strategy-kit](./kits/auth-strategy-kit.md)** - Authentication strategies (3 entries)
- **[api-design-kit](./kits/api-design-kit.md)** - API design patterns (2 entries)

## Topics

- **Authentication**: RES-20260115-001, RES-20260120-003
- **API Design**: RES-20260128-001, RES-20260202-002
- **Testing**: RES-20260125-007

---

*Auto-generated by research-advisor skill. Last sync: {timestamp}*
```

### Research Entry (entries/RES-{YYYYMMDD}-{NNN}.md)

```markdown
---
id: RES-20260202-001
created: 2026-02-02T14:32:00Z
title: GraphQL schema design for multi-tenant SaaS
requester: planner
context: Phase 2 API Layer planning
status: fresh
last_verified: 2026-02-02
tags: [graphql, multi-tenant, api-design, security]
skill: research-verified
query_hash: sha256:abc123...
---

# GraphQL Schema Design for Multi-Tenant SaaS

## Query

GraphQL schema design best practices for multi-tenant SaaS with tenant isolation requirements.

**Context:** Planning Phase 2 (API Layer) for multi-tenant SaaS. Stack: Node.js/Express/PostgreSQL. Requirements: tenant isolation, mobile+web clients. Prior research: RES-20260128-001 chose GraphQL over REST.

## Summary

GraphQL schema-level tenant context injection is the recommended approach for multi-tenant isolation. Use schema stitching with tenant-scoped resolvers to prevent cross-tenant data leaks. Performance overhead is minimal (2-3% vs non-tenant queries).

## Key Findings

1. **Schema-Level Tenant Context**
   - Inject tenant ID into GraphQL context at authentication layer
   - All resolvers automatically receive tenant context
   - Prevents accidental cross-tenant queries
   - Source: [Apollo Multi-Tenancy Guide](https://example.com) (Credibility: 92/100)

2. **Field-Level Authorization**
   - Use directive-based authorization (@auth, @tenant)
   - Schema validation catches missing tenant checks at build time
   - Reduces runtime authorization errors by 87%
   - Source: [Hasura Multi-Tenant Patterns](https://example.com) (Credibility: 88/100)

3. **Performance Considerations**
   - Schema stitching adds 2-3% overhead vs direct queries
   - Tenant-scoped DataLoader prevents N+1 problems
   - Connection pooling per tenant recommended for 100+ tenants
   - Source: [GraphQL Performance Study 2025](https://example.com) (Credibility: 85/100)

## Decision Impact

- **DEC-API-001**: Selected schema-level tenant injection pattern
- **DEC-API-002**: Implemented directive-based field authorization
- Informed Phase 2 architecture choices in MASTER_PLAN.md

## Sources

1. [Apollo Multi-Tenancy Guide](https://apollographql.com/docs/multi-tenancy) - Credibility: 92/100
2. [Hasura Multi-Tenant Patterns](https://hasura.io/learn/multi-tenant) - Credibility: 88/100
3. [GraphQL Performance Study 2025](https://graphql.org/perf/2025) - Credibility: 85/100
4. [Prisma Tenant Isolation](https://prisma.io/docs/tenant-isolation) - Credibility: 90/100

## Related Research

- [RES-20260128-001](./RES-20260128-001.md) - REST vs GraphQL comparison (led to GraphQL choice)
- Future: Need research on GraphQL subscriptions for real-time multi-tenant updates

## Metadata

- **Skill Used:** research-verified
- **Duration:** 8 minutes
- **Sources Analyzed:** 12
- **Credibility Score (avg):** 88/100
- **Implementation Status:** Applied to src/api/schema.ts

---

*Generated by research-advisor on 2026-02-02. Status will transition to 'aging' on 2026-02-17 (15 days).*
```

### Knowledge Kit (kits/{domain}-kit.md)

```markdown
---
title: API Design Knowledge Kit
domain: api-design
compiled: 2026-02-02T16:00:00Z
source_entries: [RES-20260128-001, RES-20260202-002]
status: active
last_updated: 2026-02-02
maintainer: guardian
---

# API Design Knowledge Kit

## Overview

This kit compiles research findings on API design patterns for {project_name}. It aggregates insights from multiple research sessions to provide consolidated guidance for API architecture decisions.

## Scope

- **Technology:** GraphQL vs REST evaluation, GraphQL schema design
- **Use Case:** Multi-tenant SaaS application
- **Stack:** Node.js, Express, PostgreSQL
- **Requirements:** Tenant isolation, mobile+web clients, real-time updates

## Key Findings

### GraphQL vs REST Trade-offs (RES-20260128-001)

**Decision:** Selected GraphQL for frontend flexibility and type safety.

**Rationale:**
- Frontend teams need flexible data fetching (mobile + web different requirements)
- Type-safe schema provides compile-time validation
- Subscription support for real-time updates
- 15% reduction in API endpoints vs REST equivalent

**Trade-offs:**
- ✅ Frontend flexibility, type safety, real-time subscriptions
- ❌ Slightly higher learning curve, caching complexity
- Verdict: Benefits outweigh costs for multi-client SaaS

### Multi-Tenant Schema Design (RES-20260202-002)

**Decision:** Schema-level tenant context injection with directive-based authorization.

**Pattern:**
```graphql
type Query {
  users: [User!]! @tenant
  posts: [Post!]! @tenant
}
```

**Rationale:**
- Tenant context injected at authentication layer
- All resolvers automatically tenant-scoped
- Schema directives catch missing tenant checks at build time
- 2-3% performance overhead acceptable for security guarantee

**Implementation:** Applied in src/api/schema.ts, src/api/directives/

## Synthesis

For multi-tenant SaaS with GraphQL:
1. Use schema-level tenant context (not query-level parameters)
2. Implement directive-based authorization for compile-time safety
3. Use tenant-scoped DataLoaders to prevent N+1 queries
4. Consider connection pooling per tenant at 100+ tenants

This approach balances security (tenant isolation), performance (minimal overhead), and developer experience (compile-time validation).

## Implementation References

- **MASTER_PLAN.md**: Phase 2 (API Layer) - decisions DEC-API-001, DEC-API-002
- **Code**:
  - `src/api/schema.ts` - GraphQL schema with tenant directives
  - `src/api/context.ts` - Tenant context injection
  - `src/api/directives/tenant.ts` - Tenant authorization directive
- **@decision annotations**: DEC-API-001, DEC-API-002

## Related Kits

- [auth-strategy-kit](./auth-strategy-kit.md) - Authentication patterns
- Future: Real-time subscriptions kit (pending RES-20260XXX-XXX)

## Future Research Needs

- GraphQL subscriptions for real-time multi-tenant updates
- Caching strategies for tenant-scoped queries
- Schema federation for microservices architecture

---

## Source Research Entries

### RES-20260128-001: REST vs GraphQL Comparison
[Full entry embedded or linked]

### RES-20260202-002: GraphQL Multi-Tenant Patterns
[Full entry embedded or linked]

---

*Compiled by guardian agent on 2026-02-02. Auto-updated when source entries change or new related research added.*
```

### .metadata.json (Machine-Readable Index)

```json
{
  "version": "1.0",
  "project": "example-saas-app",
  "created": "2026-02-02T10:00:00Z",
  "last_updated": "2026-02-02T16:00:00Z",
  "entries": [
    {
      "id": "RES-20260202-002",
      "created": "2026-02-02T14:32:00Z",
      "title": "GraphQL schema design for multi-tenant SaaS",
      "status": "fresh",
      "tags": ["graphql", "multi-tenant", "api-design"],
      "kit": "api-design-kit",
      "decision_impact": ["DEC-API-001", "DEC-API-002"],
      "related": ["RES-20260128-001"]
    },
    {
      "id": "RES-20260128-001",
      "created": "2026-01-28T11:15:00Z",
      "title": "REST vs GraphQL comparison",
      "status": "aging",
      "tags": ["graphql", "rest", "api-design"],
      "kit": "api-design-kit",
      "decision_impact": ["DEC-API-001"],
      "related": []
    }
  ],
  "kits": [
    {
      "name": "api-design-kit",
      "domain": "api-design",
      "entries": ["RES-20260128-001", "RES-20260202-002"],
      "last_updated": "2026-02-02T16:00:00Z",
      "status": "active"
    }
  ],
  "topics": {
    "api-design": ["RES-20260128-001", "RES-20260202-002"],
    "authentication": [],
    "testing": []
  },
  "staleness_threshold_days": {
    "fresh": 14,
    "aging": 90
  }
}
```

## Status Lifecycle

Research entries transition through status states based on age:

- **fresh**: ≤14 days old - Current and reliable
- **aging**: 15-90 days old - Still useful but consider re-verification
- **stale**: >90 days old - Should be re-researched or archived

Status is automatically calculated based on `created` timestamp.

## Discovery Protocol

When a new research agent spawns without context:

1. Check for `{project_root}/.claude/research/` directory
2. Read `README.md` for human-readable index
3. Read `.metadata.json` for machine-queryable index
4. Scan `entries/` for specific research by ID or topic
5. Check `kits/` for compiled knowledge on relevant domains

No conversation context needed - everything is in the file structure.

## Query Deduplication

Before invoking research:

1. Calculate query hash (SHA256 of normalized query text)
2. Check `.metadata.json` for matching query_hash
3. If found and status=fresh, return existing research
4. If found and status=aging/stale, offer to re-research
5. If not found, proceed with new research

## Knowledge Compilation Triggers

Knowledge kits are created when:

1. **Manual**: User/agent invokes compilation explicitly
2. **Automatic**: 3+ research entries share same tag/domain
3. **Phase Completion**: Guardian compiles research that informed the phase
4. **Staleness**: When kit's source entries become 50%+ stale, offer re-compilation

## Integration Points

- **research-advisor skill**: Creates entries in this structure
- **Hooks**: session-init, subagent-start surface research status
- **Agents**: Check research folder before researching, reference in decisions
- **Guardian**: Compiles kits, verifies research citations in @decisions

## Anti-Patterns to Avoid

❌ **Global research log** - Research must be project-specific
❌ **Bloating agent context** - Research subagent handles details, returns summaries
❌ **Stale research accumulation** - Status tracking + periodic cleanup
❌ **Broken feedback loops** - Implementation insights must flow back to research
❌ **Overcomplicated schemas** - Simple markdown + JSON, no databases

## Success Criteria

✅ New agents discover research without context
✅ Duplicate research prevented automatically
✅ Research → decision → code traceability clear
✅ Knowledge compounds via kits
✅ Minimal context window impact on calling agents
✅ Staleness detected and flagged
✅ Project-specific, not bloated with irrelevant info
